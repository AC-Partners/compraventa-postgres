# Importaciones necesarias para la aplicaci√≥n Flask
from flask import Flask, render_template, request, redirect, url_for, flash
import os
import psycopg2
import psycopg2.extras
from werkzeug.utils import secure_filename
from email.message import EmailMessage
import smtplib
import socket
import json # Importa el m√≥dulo json para cargar las actividades y sectores
import locale # Importa el m√≥dulo locale para formato num√©rico
import uuid # Para generar nombres de archivo √∫nicos en GCS y tokens
from datetime import timedelta, datetime # Necesario para generar URLs firmadas temporales y manejar fechas

# IMPORTACIONES A√ëADIDAS PARA GOOGLE CLOUD STORAGE
from google.cloud import storage # Importa la librer√≠a cliente de GCS

# Inicializaci√≥n de la aplicaci√≥n Flask
app = Flask(__name__)
# Configuraci√≥n de la clave secreta para la seguridad de Flask (sesiones, mensajes flash, etc.)
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'default-secret-key')

# ---------------------------------------------------------------
# INICIO DE LA SECCI√ìN DE CONFIGURACI√ìN DE GOOGLE CLOUD STORAGE
# ---------------------------------------------------------------

# Obtener el nombre del bucket de GCS de las variables de entorno de Render.com
# Aseg√∫rate de configurar la variable de entorno CLOUD_STORAGE_BUCKET en Render con el nombre de tu bucket.
CLOUD_STORAGE_BUCKET = os.environ.get('CLOUD_STORAGE_BUCKET')

# Inicializar el cliente de Cloud Storage
# Intentar√° cargar las credenciales desde la variable de entorno GCP_SERVICE_ACCOUNT_KEY_JSON.
# Esta variable debe contener el JSON completo de tu clave de cuenta de servicio en una sola l√≠nea.
gcs_key_json = os.environ.get('GCP_SERVICE_ACCOUNT_KEY_JSON')
if gcs_key_json:
    try:
        credentials_info = json.loads(gcs_key_json)
        storage_client = storage.Client.from_service_account_info(credentials_info)
        print("Cliente de Google Cloud Storage inicializado desde la variable de entorno JSON.")
    except json.JSONDecodeError as e:
        print(f"Error al decodificar JSON de credenciales de GCP: {e}")
        print("Aseg√∫rate de que GCP_SERVICE_ACCOUNT_KEY_JSON contiene JSON v√°lido y sin saltos de l√≠nea inesperados.")
        # En un entorno de producci√≥n real, aqu√≠ deber√≠as considerar levantar una excepci√≥n o salir.
        storage_client = None # O asigna None para indicar que no se pudo inicializar
else:
    # Si la variable GCP_SERVICE_ACCOUNT_KEY_JSON no est√° configurada,
    # el cliente intentar√° buscar credenciales por defecto (ej. GOOGLE_APPLICATION_CREDENTIALS, gcloud CLI, etc.).
    # Esto es √∫til para desarrollo local, pero en Render deber√≠as usar GCP_SERVICE_ACCOUNT_KEY_JSON.
    storage_client = storage.Client()
    print("Advertencia: GCP_SERVICE_ACCOUNT_KEY_JSON no encontrada. El cliente de GCS intentar√° credenciales por defecto.")
    print("Para Render, aseg√∫rate de configurar GCP_SERVICE_ACCOUNT_KEY_JSON y CLOUD_STORAGE_BUCKET.")

# Funci√≥n para subir un archivo a Google Cloud Storage
def upload_to_gcs(file_obj, filename, content_type):
    """
    Sube un objeto de archivo (FileStorage) a Google Cloud Storage.
    Genera un nombre de archivo √∫nico utilizando UUID para evitar colisiones.
    Retorna la URL firmada del archivo subido.
    """
    if not storage_client or not CLOUD_STORAGE_BUCKET:
        print("Error: Cliente de GCS o nombre de bucket no configurado para la subida.")
        return None, None # Retorna None para URL y nombre si hay un error de configuraci√≥n

    # Genera un nombre de archivo √∫nico para el blob en GCS
    # Esto evita colisiones si dos usuarios suben un archivo con el mismo nombre
    unique_filename = str(uuid.uuid4()) + '_' + secure_filename(filename)

    try:
        bucket = storage_client.bucket(CLOUD_STORAGE_BUCKET)
        blob = bucket.blob(unique_filename)

        # Sube el archivo. file_obj.stream es un objeto tipo archivo que blob.upload_from_file puede leer.
        blob.upload_from_file(file_obj.stream, content_type=content_type)

        # Genera una URL firmada temporal para acceder al objeto
        # La duraci√≥n de la URL es de 7 d√≠as. Ajusta seg√∫n tus necesidades.
        # Esto es seguro porque el bucket no tiene acceso p√∫blico directo.
        signed_url = blob.generate_signed_url(expiration=timedelta(days=7))
        return signed_url, unique_filename # Retorna la URL y el nombre √∫nico usado en GCS
    except Exception as e:
        print(f"Error al subir el archivo {filename} a GCS: {e}")
        return None, None # Retorna None si la subida falla

# Funci√≥n para eliminar un archivo de Google Cloud Storage
def delete_from_gcs(filename_in_gcs):
    """
    Elimina un archivo del bucket de Google Cloud Storage.
    Recibe el nombre √∫nico del archivo tal como est√° en GCS.
    """
    if not storage_client or not CLOUD_STORAGE_BUCKET or not filename_in_gcs:
        print("Advertencia: No se pudo eliminar el archivo de GCS. Cliente/Bucket no configurado o nombre de archivo vac√≠o.")
        return False

    bucket = storage_client.bucket(CLOUD_STORAGE_BUCKET)
    blob = bucket.blob(filename_in_gcs)

    try:
        # Verifica si el blob existe antes de intentar eliminarlo
        if blob.exists():
            blob.delete()
            print(f"Archivo '{filename_in_gcs}' eliminado de GCS correctamente.")
            return True
        else:
            print(f"Advertencia: El archivo '{filename_in_gcs}' no existe en GCS. No se realiz√≥ la eliminaci√≥n.")
            return False
    except Exception as e:
        print(f"Error al eliminar el archivo '{filename_in_gcs}' de GCS: {e}")
        return False

# ---------------------------------------------------------------
# FIN DE LA SECCI√ìN DE CONFIGURACI√ìN DE GOOGLE CLOUD STORAGE
# ---------------------------------------------------------------


# Variable para rastrear si la configuraci√≥n regional se estableci√≥ con √©xito
locale_set_successfully = False
try:
    # Intenta establecer la localizaci√≥n espa√±ola para el formato num√©rico.
    # 'es_ES.UTF-8' es com√∫n en sistemas Linux. 'es_ES' puede funcionar en otros.
    locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
    locale_set_successfully = True
except locale.Error:
    print("Advertencia: No se pudo establecer la localizaci√≥n 'es_ES.UTF-8'. Aseg√∫rate de que est√° instalada en tu sistema.")
    try:
        # Intenta una alternativa si la primera falla
        locale.setlocale(locale.LC_ALL, 'es_ES')
        locale_set_successfully = True
    except locale.Error:
        print("Advertencia: No se pudo establecer la localizaci√≥n 'es_ES'. Los n√∫meros ser√°n formateados manualmente.")
        # locale_set_successfully permanece False

# Carpeta donde se guardar√°n las im√°genes subidas (NO NECESARIA PARA GCS, pero la dejo si la usas para otra cosa)
# app.config['UPLOAD_FOLDER'] = 'static/uploads'
# Extensiones de archivo permitidas para las im√°genes
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}

# Carga de variables de entorno para la conexi√≥n a la base de datos y el env√≠o de emails
DATABASE_URL = os.environ.get('DATABASE_URL')
EMAIL_ORIGEN = os.environ.get('EMAIL_ORIGEN')
EMAIL_DESTINO = os.environ.get('EMAIL_DESTINO')
EMAIL_PASSWORD = os.environ.get('EMAIL_PASSWORD')
ADMIN_TOKEN = os.environ.get('ADMIN_TOKEN')

# Funci√≥n interna para formatear n√∫meros manualmente si locale falla
def _format_manual_euro(value, decimals=0):
    if value is None:
        return ""
    try:
        # Convertir a float y luego a cadena con el formato deseado
        # Primero, formato ingl√©s (coma para miles, punto para decimales)
        val_str = f"{float(value):,.{decimals}f}"
        # Luego, reemplazar para obtener formato europeo
        # Reemplazar la coma de miles (ingl√©s) por un marcador temporal
        val_str = val_str.replace(",", "TEMP_COMMA_PLACEHOLDER")
        # Reemplazar el punto decimal (ingl√©s) por una coma
        val_str = val_str.replace(".", ",")
        # Reemplazar el marcador temporal por un punto de miles (europeo)
        val_str = val_str.replace("TEMP_COMMA_PLACEHOLDER", ".")
        return val_str
    except (ValueError, TypeError):
        return str(value) # Devuelve el valor original si no se puede formatear

# Filtro de Jinja2 para formato de n√∫meros europeos (utiliza locale o manual)
def format_euro_number(value, decimals=0):
    if value is None:
        return ""
    # Si la localizaci√≥n se estableci√≥ con √©xito, intentar usar locale.format_string
    if locale_set_successfully:
        try:
            return locale.format_string(f"%.{decimals}f", float(value), grouping=True)
        except (ValueError, TypeError):
            # Fallback a manual si locale.format_string falla por alg√∫n motivo
            # con un valor num√©rico v√°lido (ej. valor fuera de rango para locale)
            return _format_manual_euro(value, decimals)
    else:
        # Si la localizaci√≥n no se pudo establecer, usar siempre el formato manual
        return _format_manual_euro(value, decimals)

# Registra el filtro personalizado 'euro_format' en el entorno de Jinja2.
# Ahora puedes usar {{ variable | euro_format(2) }} en tus plantillas HTML.
app.jinja_env.filters['euro_format'] = format_euro_number


# Definici√≥n de actividades y sectores en formato JSON (como una cadena de texto)
# Luego se parsea a un diccionario de Python
ACTIVIDADES_Y_SECTORES = '''
{
  "AGRICULTURA, GANADER√çA, SILVICULTURA Y PESCA": [
    "Agricultura, ganader√≠a, caza y servicios relacionados con las mismas",
    "Silvicultura y explotaci√≥n forestal",
    "Pesca y acuicultura"
  ],
  "INDUSTRIAS EXTRACTIVAS": [
    "Extracci√≥n de antracita, hulla, y lignito",
    "Extracci√≥n de crudo de petr√≥leo y gas natural",
    "Extracci√≥n de minerales met√°licos",
    "Otras industrias extractivas",
    "Actividades de apoyo a las industrias extractivas"
  ],
  "INDUSTRIA MANUFACTURERA": [
    "Industria alimentaria",
    "Fabricaci√≥n de bebidas",
    "Industria del tabaco",
    "Industria textil",
    "Confecci√≥n de prendas de vestir",
    "Industria del cuero y productos relacionados de otros materiales",
    "Industria de la madera y del corcho, excepto muebles; cester√≠a y esparter√≠a",
    "Industria del papel",
    "Artes gr√°ficas y reproducci√≥n de soportes grabados",
    "Coquer√≠as y refino de petr√≥leo",
    "Industria qu√≠mica",
    "Fabricaci√≥n de productos farmac√©uticos",
    "Fabricaci√≥n de productos de caucho y pl√°sticos",
    "Fabricaci√≥n de otros productos minerales no met√°licos",
    "Metalurgia",
    "Fabricaci√≥n de productos met√°licos, excepto maquinaria y equipo",
    "Fabricaci√≥n de productos inform√°ticos, electr√≥nicos y √≥pticos",
    "Fabricaci√≥n de material y equipo el√©ctrico",
    "Fabricaci√≥n de maquinaria y equipo n.c.o.p.",
    "Fabricaci√≥n de veh√≠culos de motor, remolques y semirremolques",
    "Fabricaci√≥n de otro material de transporte",
    "Fabricaci√≥n de muebles",
    "Otras industrias manufactureras",
    "Reparaci√≥n, mantenimiento e instalaci√≥n de maquinaria y equipos"
  ],
  "SUMINISTRO DE ENERGIA ELECTRICA, GAS, VAPOR Y AIRE ACONDICIONADO": [
    "Suministro de energ√≠a el√©ctrica, gas, vapor y aire acondicionado"
  ],
  "SUMINISTRO DE AGUA, ACTIVIDADES DE SANEAMIENTO, GESTI√ìN DE RESIDUOS Y DESCONTAMINACI√ìN": [
    "Captaci√≥n, depuraci√≥n y distribuci√≥n de agua",
    "Recogida y tratamiento de aguas residuales",
    "Actividades de recogida, tratamiento y eliminaci√≥n de residuos",
    "Actividades de descontaminaci√≥n y otros servicios de gesti√≥n de residuos"
  ],
  "CONSTRUCCI√ìN": [
    "Construcci√≥n de edificios",
    "Ingenier√≠a civil",
    "Actividades de construcci√≥n especializada"
  ],
  "COMERCIO AL POR MAYOR Y AL POR MENOR": [
    "Comercio al por mayor",
    "Comercio al por menor"
  ],
  "TRANSPORTE Y ALMACENAMIENTO": [
    "Transporte terrestre y por tuber√≠a",
    "Transporte mar√≠timo y por v√≠as navegables interiores",
    "Transporte a√©reo",
    "Dep√≥sito, almacenamiento y actividades auxiliares del transporte",
    "Actividades postales y de mensajer√≠a"
  ],
  "HOSTELER√çA": [
    "Servicios de alojamiento",
    "Servicios de comidas y bebidas"
  ],
  "ACTIVIDADES DE EDICI√ìN, RADIODIFUSI√ìN Y PRODUCCI√ìN Y DISTRIBUCI√ìN DE CONTENIDOS": [
    "Edici√≥n",
    "Producci√≥n cinematogr√°fica, de v√≠deo y de programas de televisi√≥n, grabaci√≥n de sonido y edici√≥n musical",
    "Actividades de programaci√≥n, radiodifusi√≥n, agencias de noticias y otras actividades de distribuci√≥n de contenidos"
  ],
  "TELECOMUNICACIONES, PROGRAMACI√ìN INFORM√ÅTICA, CONSULTOR√çA, INFRAESTRUCTURA INFORM√ÅTICA Y OTROS SERVICIOS DE INFORMACI√ìN": [
    "Telecomunicaciones",
    "Programaci√≥n, consultor√≠a y otras actividades relacionadas con la inform√°tica",
    "Infraestructura inform√°tica, tratamiento de datos, hosting y otras actividades de servicios de informaci√≥n"
  ],
  "ACTIVIDADES FINANCIERAS Y DE SEGUROS": [
    "Servicios financieros, excepto seguros y fondos de pensiones",
    "Seguros, reaseguros y planes de pensiones, excepto seguridad social obligatoria",
    "Actividades auxiliares a los servicios financieros y a los seguros"
  ],
  "ACTIVIDADES INMOBILIARIAS": [
    "Actividades inmobiliarias"
  ],
  "ACTIVIDADES PROFESIONALES, CIENT√çFICAS Y T√âCNICAS": [
    "Actividades jur√≠dicas y de contabilidad",
    "Actividades de las sedes centrales y consultor√≠a de gesti√≥n empresarial",
    "Servicios t√©cnicos de arquitectura e ingenier√≠a; ensayos y an√°lisis t√©cnicos",
    "Investigaci√≥n y desarrollo",
    "Actividades de publicidad, estudios de mercado, relaciones p√∫blicas y comunicaci√≥n",
    "Otras actividades profesionales, cient√≠ficas y t√©cnicas",
    "Actividades veterinarias"
  ],
  "ACTIVIDADES ADMINISTRATIVAS Y SERVICIOS AUXILIARES": [
    "Actividades de alquiler",
    "Actividades relacionadas con el empleo",
    "Actividades de agencias de viajes, operadores tur√≠sticos, servicios de reservas y actividades relacionadas",
    "Servicios de investigaci√≥n y seguridad",
    "Servicios a edificios y actividades de jardiner√≠a",
    "Actividades administrativas de oficina y otras actividades auxiliares a las empresas"
  ],
  "ADMINISTRACI√ìN P√öBLICA Y DEFENSA; SEGURIDAD SOCIAL OBLIGATORIA": [
    "Administraci√≥n p√∫blica y defensa; seguridad social obligatoria"
  ],
  "EDUCACI√ìN": [
    "Educaci√≥n"
  ],
  "ACTIVIDADES SANITARIAS Y DE SERVICIOS SOCIALES": [
    "Actividades sanitarias",
    "Asistencia en establecimientos residenciales",
    "Actividades de servicios sociales sin alojamiento"
  ],
  "ACTIVIDADES ART√çSTICAS, DEPORTIVAS Y DE ENTRETENIMIENTO": [
    "Actividades de creaci√≥n art√≠stica y artes esc√©nicas",
    "Actividades de bibliotecas, archivos, museos y otras actividades culturales",
    "Actividades de juegos de azar y apuestas",
    "Actividades deportivas, recreativas y de entretenimiento"
  ],
  "OTROS SERVICIOS": [
    "Actividades asociativas",
    "Reparaci√≥n y mantenimiento de ordenadores, art√≠culos personales y enseres dom√©sticos y veh√≠culos de motor y motocicletas",
    "Servicios personales"
  ],
  "ACTIVIDADES DE LOS HOGARES COMO EMPLEADORES DE PERSONAL DOM√âSTICO Y COMO PRODUCTORES DE BIENES Y SERVICIOS PARA USO PROPIO": [
    "Actividades de los hogares como empleadores de personal dom√©stico",
    "Actividades de los hogares como productores de bienes y servicios para uso propio"
  ]
}
'''
ACTIVIDADES_Y_SECTORES = json.loads(ACTIVIDADES_Y_SECTORES)

# Lista de provincias de Espa√±a (para usar en los desplegables de ubicaci√≥n)
PROVINCIAS_ESPANA = [
    '√Ålava', 'Albacete', 'Alicante', 'Almer√≠a', 'Asturias', '√Åvila',
    'Badajoz', 'Barcelona', 'Burgos', 'C√°ceres', 'C√°diz', 'Cantabria',
    'Castell√≥n', 'Ciudad Real', 'C√≥rdoba', 'Cuenca', 'Gerona', 'Granada',
    'Guadalajara', 'Guip√∫zcoa', 'Huelva', 'Huesca', 'Islas Baleares',
    'Ja√©n', 'La Coru√±a', 'La Rioja', 'Las Palmas', 'Le√≥n', 'L√©rida',
    'Lugo', 'Madrid', 'M√°laga', 'Murcia', 'Navarra', 'Orense',
    'Palencia', 'Pontevedra', 'Salamanca', 'Santa Cruz de Tenerife',
    'Segovia', 'Sevilla', 'Soria', 'Tarragona', 'Teruel', 'Toledo',
    'Valencia', 'Valladolid', 'Vizcaya', 'Zamora', 'Zaragoza'
]


# Funci√≥n para establecer la conexi√≥n a la base de datos PostgreSQL
def get_db_connection():
    # Parche para psycopg2 con Render.com (fuerza IPv4 para la conexi√≥n a la DB)
    orig_getaddrinfo = socket.getaddrinfo
    socket.getaddrinfo = lambda *args, **kwargs: [
        info for info in orig_getaddrinfo(*args, **kwargs) if info[0] == socket.AF_INET
    ]
    # Conecta a la base de datos usando la URL de entorno
    conn = psycopg2.connect(DATABASE_URL, sslmode='require')
    # Configura el cursor para devolver diccionarios (acceso por nombre de columna)
    conn.cursor_factory = psycopg2.extras.RealDictCursor
    return conn

# Funci√≥n para verificar si un archivo tiene una extensi√≥n permitida
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# Funci√≥n para enviar un correo electr√≥nico de notificaci√≥n de nueva empresa (al admin)
def enviar_email_notificacion_admin(empresa_nombre, email_usuario):
    msg = EmailMessage()
    msg['Subject'] = f"üì© Nueva empresa publicada: {empresa_nombre}"
    msg['From'] = EMAIL_ORIGEN
    msg['To'] = EMAIL_DESTINO
    msg.set_content(f"""
¬°Se ha publicado una nueva empresa en el portal!

Nombre: {empresa_nombre}
Contacto: {email_usuario}
""")
    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
            smtp.login(EMAIL_ORIGEN, EMAIL_PASSWORD)
            smtp.send_message(msg)
        print(f"Correo de notificaci√≥n de admin enviado para {empresa_nombre}")
    except smtplib.SMTPException as e:
        print(f"Error al enviar email de notificaci√≥n de admin: {e}")
    except Exception as e:
        print(f"Error inesperado al enviar email de notificaci√≥n de admin: {e}")

# Funci√≥n para enviar un correo electr√≥nico de inter√©s al anunciante (MODIFICADA)
def enviar_email_interes_anunciante(empresa_id, email_anunciante, nombre_interesado, email_interesado, telefono_interesado, mensaje_interes): # Recibe nuevos campos
    msg = EmailMessage()
    # Asunto ahora usa el ID de referencia del anuncio
    msg['Subject'] = f"‚úâÔ∏è Inter√©s en tu anuncio con referencia: {empresa_id} desde AC Partners"
    msg['From'] = EMAIL_ORIGEN
    msg['To'] = email_anunciante
    
    email_body = f"""
Hola,

Un posible comprador est√° interesado en tu anuncio con referencia "{empresa_id}" en AC Partners.

Estos son los datos del interesado:
Nombre: {nombre_interesado}
Email: {email_interesado}
Tel√©fono: {telefono_interesado if telefono_interesado else 'No proporcionado'}

Este es el mensaje que te ha enviado:
---
{mensaje_interes}
---

Te recomendamos responder a esta persona directamente utilizando los datos de contacto proporcionados.

Gracias por confiar en AC Partners.
"""
    msg.set_content(email_body)

    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
            smtp.login(EMAIL_ORIGEN, EMAIL_PASSWORD)
            smtp.send_message(msg)
        print(f"Correo de inter√©s enviado al anunciante {email_anunciante} para anuncio ID: {empresa_id}")
    except smtplib.SMTPException as e:
        print(f"Error al enviar email de inter√©s al anunciante: {e}")
    except Exception as e:
        print(f"Error inesperado al enviar email de inter√©s al anunciante: {e}")

# NUEVA FUNCI√ìN: Para enviar correo de confirmaci√≥n al anunciante con enlaces de gesti√≥n
def enviar_email_confirmacion_anunciante(empresa_id, email_anunciante, token_edicion):
    # Genera las URLs de edici√≥n y eliminaci√≥n, incluyendo el token de edici√≥n
    edit_url = url_for('editar_anuncio_anunciante', empresa_id=empresa_id, token=token_edicion, _external=True)
    delete_url = url_for('eliminar_anuncio_anunciante', empresa_id=empresa_id, token=token_edicion, _external=True)

    msg = EmailMessage()
    msg['Subject'] = f"‚úÖ Anuncio Publicado y Enlaces de Gesti√≥n - Ref: {empresa_id}"
    msg['From'] = EMAIL_ORIGEN
    msg['To'] = email_anunciante
    msg.set_content(f"""
¬°Hola!

Tu anuncio con referencia **{empresa_id}** ha sido publicado correctamente en AC Partners.

Puedes gestionar tu anuncio a trav√©s de los siguientes enlaces (gu√°rdalos bien, son privados para tu anuncio y v√°lidos por 7 d√≠as):

* **Modificar Anuncio:** {edit_url}
* **Anular Anuncio:** {delete_url}

Te recomendamos no compartir estos enlaces, ya que permiten la gesti√≥n directa de tu anuncio.
Si los enlaces caducan y necesitas gestionar tu anuncio, por favor, contacta con nosotros.

Gracias por usar AC Partners.
""")
    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
            smtp.login(EMAIL_ORIGEN, EMAIL_PASSWORD)
            smtp.send_message(msg)
        print(f"Correo de confirmaci√≥n con enlaces de gesti√≥n enviado a {email_anunciante} para anuncio ID: {empresa_id}")
    except smtplib.SMTPException as e:
        print(f"Error al enviar email de confirmaci√≥n al anunciante: {e}")
    except Exception as e:
        print(f"Error inesperado al enviar email de confirmaci√≥n al anunciante: {e}")


# Ruta principal de la aplicaci√≥n: muestra el listado de empresas
@app.route('/', methods=['GET'])
def index():
    # Obtiene par√°metros de filtro de la URL
    provincia = request.args.get('provincia')
    pais = request.args.get('pais', 'Espa√±a') # Valor por defecto 'Espa√±a'
    actividad = request.args.get('actividad')
    sector = request.args.get('sector')
    # Conversi√≥n a float para rangos de facturaci√≥n y precio de venta
    min_fact = request.args.get('min_facturacion', 0, type=float)
    max_fact = request.args.get('max_facturacion', 1e12, type=float) # 1e12 es un n√∫mero muy grande para el m√°ximo
    max_precio = request.args.get('max_precio', 1e12, type=float)

    conn = get_db_connection()
    cur = conn.cursor()

    # Construcci√≥n din√°mica de la consulta SQL para filtrar empresas
    query = "SELECT * FROM empresas WHERE facturacion BETWEEN %s AND %s AND precio_venta <= %s AND active = TRUE"
    params = [min_fact, max_fact, max_precio]

    if provincia:
        query += " AND ubicacion = %s" # Cambiado a 'ubicacion' para coincidir con la columna en DB
        params.append(provincia)
    if pais:
        query += " AND pais = %s"
        params.append(pais)
    if actividad:
        query += " AND actividad = %s"
        params.append(actividad)
    if sector:
        query += " AND sector = %s"
        params.append(sector)

    cur.execute(query, tuple(params))
    empresas = cur.fetchall() # Obtiene todos los resultados

    cur.close()
    conn.close()

    # Renderiza la plantilla index.html con las empresas y los datos para los desplegables
    return render_template('index.html', empresas=empresas, actividades=list(ACTIVIDADES_Y_SECTORES.keys()), sectores=[], actividades_dict=ACTIVIDADES_Y_SECTORES, provincias=PROVINCIAS_ESPANA)

# Ruta para publicar una nueva empresa
@app.route('/publicar', methods=['GET', 'POST'])
def publicar():
    if request.method == 'POST':
        # Obtiene datos del formulario (campos de texto)
        nombre = request.form['nombre']
        email_contacto = request.form['email_contacto']
        actividad = request.form['actividad']
        sector = request.form['sector']
        pais = request.form['pais']
        ubicacion = request.form['ubicacion'] # Ahora ser√° una provincia de PROVINCIAS_ESPANA
        tipo_negocio = request.form['tipo_negocio'] # Nuevo campo
        descripcion = request.form['descripcion']
        local_propiedad = request.form['local_propiedad']

        # --- Manejo y validaci√≥n de campos num√©ricos ---
        # Se asume que estos campos son obligatorios en el front-end (HTML con 'required').
        # Se usa un bloque try-except para capturar posibles errores de conversi√≥n
        # si la validaci√≥n del front-end falla o es omitida.
        try:
            facturacion = float(request.form['facturacion'])
            numero_empleados = int(request.form['numero_empleados'])
            resultado_antes_impuestos = float(request.form['resultado_antes_impuestos'])
            deuda = float(request.form['deuda'])
            precio_venta = float(request.form['precio_venta'])
        except ValueError:
            flash('Error: Aseg√∫rate de que todos los campos num√©ricos est√©n rellenados correctamente.', 'danger')
            # Si hay un error, vuelve a renderizar el formulario con los datos ya introducidos
            return render_template('vender_empresa.html',
                                   actividades=list(ACTIVIDADES_Y_SECTORES.keys()),
                                   actividades_dict=ACTIVIDADES_Y_SECTORES,
                                   provincias=PROVINCIAS_ESPANA,
                                   form_data=request.form)

        imagen_url = None
        imagen_filename_gcs = None # Para almacenar el nombre del archivo en GCS

        # Manejo de la subida de imagen
        if 'imagen' in request.files:
            file = request.files['imagen']
            if file and allowed_file(file.filename):
                # Usar la funci√≥n de subida a GCS
                imagen_url, imagen_filename_gcs = upload_to_gcs(file, file.filename, file.content_type)
                if not imagen_url:
                    flash('Error al subir la imagen a Google Cloud Storage.', 'danger')
                    return redirect(url_for('publicar')) # Redirige al formulario si falla la subida

        conn = get_db_connection()
        cur = conn.cursor()

        try:
            # Generar token_edicion y token_expiracion
            token_edicion = str(uuid.uuid4())
            token_expiracion = datetime.now() + timedelta(days=7) # V√°lido por 7 d√≠as

            cur.execute("""
                INSERT INTO empresas (
                    nombre, email_contacto, actividad, sector, pais, ubicacion, tipo_negocio,
                    descripcion, facturacion, numero_empleados, local_propiedad,
                    resultado_antes_impuestos, deuda, precio_venta, imagen_url, imagen_filename_gcs,
                    token_edicion, token_expiracion, active
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, TRUE) RETURNING id
            """, (
                nombre, email_contacto, actividad, sector, pais, ubicacion, tipo_negocio,
                descripcion, facturacion, numero_empleados, local_propiedad,
                resultado_antes_impuestos, deuda, precio_venta, imagen_url, imagen_filename_gcs,
                token_edicion, token_expiracion
            ))
            empresa_id = cur.fetchone()['id'] # Obtener el ID de la empresa reci√©n insertada
            conn.commit()

            # Env√≠o de notificaciones por email
            enviar_email_notificacion_admin(nombre, email_contacto) # Notifica al admin
            enviar_email_confirmacion_anunciante(empresa_id, email_contacto, token_edicion) # Notifica al anunciante

            flash('¬°Anuncio publicado con √©xito! Revisa tu correo para los enlaces de gesti√≥n.', 'success')
            return redirect(url_for('index')) # Redirige a la p√°gina principal
        except psycopg2.Error as e:
            conn.rollback() # Revierte cualquier cambio en caso de error
            print(f"Error de base de datos al publicar empresa: {e}")
            flash('Error al publicar el anuncio. Por favor, int√©ntalo de nuevo.', 'danger')
        finally:
            cur.close()
            conn.close()

    # Si es GET, o si hubo un error en POST, renderiza el formulario
    return render_template('vender_empresa.html',
                           actividades=list(ACTIVIDADES_Y_SECTORES.keys()),
                           actividades_dict=ACTIVIDADES_Y_SECTORES,
                           provincias=PROVINCIAS_ESPANA)

# Ruta para ver los detalles de una empresa y contactar al vendedor
@app.route('/detalle/<int:empresa_id>', methods=['GET', 'POST'])
def detalle(empresa_id):
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM empresas WHERE id = %s AND active = TRUE", (empresa_id,))
    empresa = cur.fetchone() # Obtiene una sola empresa
    cur.close()
    conn.close()

    if not empresa:
        flash('Empresa no encontrada.', 'warning')
        return redirect(url_for('index')) # Redirige si la empresa no existe

    if request.method == 'POST':
        # Procesa el formulario de contacto del interesado
        nombre_interesado = request.form['nombre_interesado']
        email_interesado = request.form['email_interesado']
        telefono_interesado = request.form.get('telefono_interesado') # Usa .get para que sea opcional
        mensaje_interes = request.form['mensaje_interes']

        # Env√≠a el email al anunciante
        # Aseg√∫rate de que email_contacto de la empresa est√© disponible
        if empresa['email_contacto']:
            enviar_email_interes_anunciante(
                empresa['id'], # Pasa el ID de la empresa como referencia
                empresa['email_contacto'],
                nombre_interesado,
                email_interesado,
                telefono_interesado,
                mensaje_interes
            )
            flash('¬°Tu mensaje ha sido enviado al anunciante!', 'success')
        else:
            flash('No se pudo enviar el mensaje. El anunciante no tiene un correo de contacto.', 'danger')
        # Redirige para evitar el reenv√≠o del formulario al recargar la p√°gina
        return redirect(url_for('detalle', empresa_id=empresa_id))

    return render_template('detalle.html', empresa=empresa)

# Ruta de edici√≥n para el ADMINISTRADOR
@app.route('/editar/<int:empresa_id>', methods=['GET', 'POST'])
def editar(empresa_id):
    # Requiere un token de administrador para acceder
    token = request.args.get('admin_token')
    if token != ADMIN_TOKEN:
        flash("Acceso denegado. Se requiere token de administrador.", 'danger')
        return redirect(url_for('index'))

    conn = get_db_connection()
    cur = conn.cursor()

    if request.method == 'POST':
        # Determina si la acci√≥n es 'actualizar' o 'eliminar'
        action = request.form.get('action')
        
        if action == 'eliminar':
            # Obtener el nombre del archivo de GCS antes de eliminar la entrada de la DB
            cur.execute("SELECT imagen_filename_gcs FROM empresas WHERE id = %s", (empresa_id,))
            empresa_data = cur.fetchone()
            if empresa_data and empresa_data['imagen_filename_gcs']:
                delete_from_gcs(empresa_data['imagen_filename_gcs']) # Eliminar de GCS
            
            cur.execute("DELETE FROM empresas WHERE id = %s", (empresa_id,))
            conn.commit()
            flash('Anuncio eliminado con √©xito.', 'success')
            cur.close()
            conn.close()
            return redirect(url_for('admin', admin_token=ADMIN_TOKEN)) # Redirige al panel de admin
        
        elif action == 'actualizar':
            # L√≥gica para actualizar el anuncio
            # Obtener datos del formulario
            nombre = request.form['nombre']
            email_contacto = request.form['email_contacto']
            actividad = request.form['actividad']
            sector = request.form['sector']
            pais = request.form['pais']
            ubicacion = request.form['ubicacion']
            tipo_negocio = request.form['tipo_negocio']
            descripcion = request.form['descripcion']
            local_propiedad = request.form['local_propiedad']
            
            try:
                facturacion = float(request.form['facturacion'])
                numero_empleados = int(request.form['numero_empleados'])
                resultado_antes_impuestos = float(request.form['resultado_antes_impuestos'])
                deuda = float(request.form['deuda'])
                precio_venta = float(request.form['precio_venta'])
                active = 'active' in request.form # Checkbox para activar/desactivar
            except ValueError:
                flash('Error: Aseg√∫rate de que todos los campos num√©ricos est√©n rellenados correctamente.', 'danger')
                empresa_actual = {k: request.form[k] for k in request.form if k != 'imagen'}
                # Asegura que los valores num√©ricos se mantengan en el formulario
                empresa_actual['facturacion'] = request.form.get('facturacion')
                empresa_actual['numero_empleados'] = request.form.get('numero_empleados')
                empresa_actual['resultado_antes_impuestos'] = request.form.get('resultado_antes_impuestos')
                empresa_actual['deuda'] = request.form.get('deuda')
                empresa_actual['precio_venta'] = request.form.get('precio_venta')
                empresa_actual['active'] = 'active' in request.form
                return render_template('editar.html', empresa=empresa_actual,
                                       actividades=list(ACTIVIDADES_Y_SECTORES.keys()),
                                       actividades_dict=ACTIVIDADES_Y_SECTORES,
                                       provincias=PROVINCIAS_ESPANA,
                                       admin_token=ADMIN_TOKEN)

            # Obtener datos actuales para la imagen
            cur.execute("SELECT imagen_url, imagen_filename_gcs FROM empresas WHERE id = %s", (empresa_id,))
            current_image_data = cur.fetchone()
            imagen_url = current_image_data['imagen_url']
            imagen_filename_gcs = current_image_data['imagen_filename_gcs']

            # Manejo de la nueva subida de imagen
            if 'imagen' in request.files and request.files['imagen'].filename != '':
                file = request.files['imagen']
                if file and allowed_file(file.filename):
                    new_imagen_url, new_imagen_filename_gcs = upload_to_gcs(file, file.filename, file.content_type)
                    if new_imagen_url:
                        # Si hay una nueva imagen, eliminar la antigua de GCS
                        if imagen_filename_gcs:
                            delete_from_gcs(imagen_filename_gcs)
                        imagen_url = new_imagen_url
                        imagen_filename_gcs = new_imagen_filename_gcs
                    else:
                        flash('Error al subir la nueva imagen.', 'danger')
                        # Mantener los datos actuales y el token
                        cur.execute("SELECT * FROM empresas WHERE id = %s", (empresa_id,))
                        empresa = cur.fetchone()
                        return render_template('editar.html', empresa=empresa,
                                               actividades=list(ACTIVIDADES_Y_SECTORES.keys()),
                                               actividades_dict=ACTIVIDADES_Y_SECTORES,
                                               provincias=PROVINCIAS_ESPANA,
                                               admin_token=ADMIN_TOKEN)
            
            # Actualizar la base de datos
            cur.execute("""
                UPDATE empresas SET
                    nombre = %s,
                    email_contacto = %s,
                    actividad = %s,
                    sector = %s,
                    pais = %s,
                    ubicacion = %s,
                    tipo_negocio = %s,
                    descripcion = %s,
                    facturacion = %s,
                    numero_empleados = %s,
                    local_propiedad = %s,
                    resultado_antes_impuestos = %s,
                    deuda = %s,
                    precio_venta = %s,
                    imagen_url = %s,
                    imagen_filename_gcs = %s,
                    active = %s
                WHERE id = %s
            """, (
                nombre, email_contacto, actividad, sector, pais, ubicacion, tipo_negocio,
                descripcion, facturacion, numero_empleados, local_propiedad,
                resultado_antes_impuestos, deuda, precio_venta, imagen_url, imagen_filename_gcs,
                active, empresa_id
            ))
            conn.commit()
            flash('Anuncio actualizado con √©xito.', 'success')
            cur.close()
            conn.close()
            return redirect(url_for('admin', admin_token=ADMIN_TOKEN)) # Redirige al panel de admin
    
    # Si es GET, o si la acci√≥n no es reconocida, carga los datos para edici√≥n
    cur.execute("SELECT * FROM empresas WHERE id = %s", (empresa_id,))
    empresa = cur.fetchone()
    cur.close()
    conn.close()

    if not empresa:
        flash('Anuncio no encontrado.', 'warning')
        return redirect(url_for('admin', admin_token=ADMIN_TOKEN))

    return render_template('editar.html', empresa=empresa, actividades=list(ACTIVIDADES_Y_SECTORES.keys()), sectores=[], actividades_dict=ACTIVIDADES_Y_SECTORES, provincias=PROVINCIAS_ESPANA, admin_token=ADMIN_TOKEN)


# NUEVA RUTA: Editar anuncio para el ANUNCIANTE (usando token_edicion)
@app.route('/anuncio/editar/<int:empresa_id>/<string:token>', methods=['GET', 'POST'])
def editar_anuncio_anunciante(empresa_id, token):
    conn = get_db_connection()
    cur = conn.cursor()

    # Verificar el token y su expiraci√≥n
    cur.execute("SELECT * FROM empresas WHERE id = %s AND token_edicion = %s", (empresa_id, token))
    empresa = cur.fetchone()

    if not empresa:
        flash("Acceso denegado o token inv√°lido.", 'danger')
        cur.close()
        conn.close()
        return redirect(url_for('index'))

    # Comprobar si el token ha expirado
    if empresa['token_expiracion'] and datetime.now(empresa['token_expiracion'].tzinfo) > empresa['token_expiracion']:
        flash("El enlace de edici√≥n ha caducado. Por favor, contacta con soporte si necesitas modificar tu anuncio.", 'danger')
        cur.close()
        conn.close()
        return redirect(url_for('index'))


    if request.method == 'POST':
        # L√≥gica para actualizar el anuncio
        # Obtener datos del formulario
        nombre = request.form['nombre']
        email_contacto = request.form['email_contacto']
        actividad = request.form['actividad']
        sector = request.form['sector']
        pais = request.form['pais']
        ubicacion = request.form['ubicacion']
        tipo_negocio = request.form['tipo_negocio']
        descripcion = request.form['descripcion']
        local_propiedad = request.form['local_propiedad']
        
        try:
            facturacion = float(request.form['facturacion'])
            numero_empleados = int(request.form['numero_empleados'])
            resultado_antes_impuestos = float(request.form['resultado_antes_impuestos'])
            deuda = float(request.form['deuda'])
            precio_venta = float(request.form['precio_venta'])
            # El campo 'active' no se expone al anunciante en esta ruta
        except ValueError:
            flash('Error: Aseg√∫rate de que todos los campos num√©ricos est√©n rellenados correctamente.', 'danger')
            # Vuelve a cargar la p√°gina con los datos actuales del formulario
            empresa_actual = {k: request.form[k] for k in request.form if k != 'imagen'}
            empresa_actual['id'] = empresa_id # Asegura que el ID est√© presente para la URL
            return render_template('editar_anunciante.html', empresa=empresa_actual,
                                   actividades=list(ACTIVIDADES_Y_SECTORES.keys()),
                                   actividades_dict=ACTIVIDADES_Y_SECTORES,
                                   provincias=PROVINCIAS_ESPANA)

        # Obtener datos actuales para la imagen
        cur.execute("SELECT imagen_url, imagen_filename_gcs FROM empresas WHERE id = %s", (empresa_id,))
        current_image_data = cur.fetchone()
        imagen_url = current_image_data['imagen_url']
        imagen_filename_gcs = current_image_data['imagen_filename_gcs']

        # Manejo de la nueva subida de imagen
        if 'imagen' in request.files and request.files['imagen'].filename != '':
            file = request.files['imagen']
            if file and allowed_file(file.filename):
                new_imagen_url, new_imagen_filename_gcs = upload_to_gcs(file, file.filename, file.content_type)
                if new_imagen_url:
                    # Si hay una nueva imagen, eliminar la antigua de GCS
                    if imagen_filename_gcs:
                        delete_from_gcs(imagen_filename_gcs)
                    imagen_url = new_imagen_url
                    imagen_filename_gcs = new_imagen_filename_gcs
                else:
                    flash('Error al subir la nueva imagen.', 'danger')
                    # Recargar datos de la empresa para re-renderizar el formulario
                    cur.execute("SELECT * FROM empresas WHERE id = %s", (empresa_id,))
                    empresa = cur.fetchone()
                    cur.close()
                    conn.close()
                    return render_template('editar_anunciante.html', empresa=empresa,
                                           actividades=list(ACTIVIDADES_Y_SECTORES.keys()),
                                           actividades_dict=ACTIVIDADES_Y_SECTORES,
                                           provincias=PROVINCIAS_ESPANA)

        try:
            # Actualizar la base de datos (sin modificar 'active' o 'token_edicion'/'token_expiracion')
            cur.execute("""
                UPDATE empresas SET
                    nombre = %s,
                    email_contacto = %s,
                    actividad = %s,
                    sector = %s,
                    pais = %s,
                    ubicacion = %s,
                    tipo_negocio = %s,
                    descripcion = %s,
                    facturacion = %s,
                    numero_empleados = %s,
                    local_propiedad = %s,
                    resultado_antes_impuestos = %s,
                    deuda = %s,
                    precio_venta = %s,
                    imagen_url = %s,
                    imagen_filename_gcs = %s
                WHERE id = %s AND token_edicion = %s
            """, (
                nombre, email_contacto, actividad, sector, pais, ubicacion, tipo_negocio,
                descripcion, facturacion, numero_empleados, local_propiedad,
                resultado_antes_impuestos, deuda, precio_venta, imagen_url, imagen_filename_gcs,
                empresa_id, token
            ))
            conn.commit()
            flash('Anuncio actualizado con √©xito.', 'success')
            return redirect(url_for('detalle', empresa_id=empresa_id)) # Redirige al detalle del anuncio
        except psycopg2.Error as e:
            conn.rollback()
            print(f"Error de base de datos al actualizar empresa (anunciante): {e}")
            flash('Error al actualizar el anuncio. Por favor, int√©ntalo de nuevo.', 'danger')
        finally:
            cur.close()
            conn.close()

    # Si es GET, o si hubo un error de DB, renderiza el formulario con los datos actuales
    cur.close()
    conn.close() # Cierra la conexi√≥n de la primera b√∫squeda
    
    # Abrir una nueva conexi√≥n para la b√∫squeda de datos para renderizar el formulario GET
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM empresas WHERE id = %s AND token_edicion = %s", (empresa_id, token))
    empresa = cur.fetchone() # Vuelve a buscar la empresa para asegurar datos frescos o si el POST fall√≥
    cur.close()
    conn.close()

    if not empresa: # Doble chequeo por si algo fall√≥ en la re-b√∫squeda
        flash("Anuncio no encontrado o acceso denegado. (DEBUG: Esto no deber√≠a ocurrir si pasaste la validaci√≥n inicial)", 'danger')
        return redirect(url_for('index'))

    # Renderiza la plantilla de edici√≥n espec√≠fica para el anunciante
    # Nota: Podr√≠as querer crear una plantilla 'editar_anunciante.html' si quieres que el anunciante vea un formulario diferente.
    # Por simplicidad, se usa la misma plantilla 'editar.html' pero el controlador maneja las diferencias.
    return render_template('editar.html', empresa=empresa, actividades=list(ACTIVIDADES_Y_SECTORES.keys()), sectores=[], actividades_dict=ACTIVIDADES_Y_SECTORES, provincias=PROVINCIAS_ESPANA)


# NUEVA RUTA: Eliminar anuncio para el ANUNCIANTE (usando token_edicion)
@app.route('/anuncio/eliminar/<int:empresa_id>/<string:token>', methods=['GET'])
def eliminar_anuncio_anunciante(empresa_id, token):
    conn = get_db_connection()
    cur = conn.cursor()

    # Verificar el token y su expiraci√≥n
    cur.execute("SELECT imagen_filename_gcs, token_expiracion FROM empresas WHERE id = %s AND token_edicion = %s", (empresa_id, token))
    empresa_data = cur.fetchone()

    if not empresa_data:
        flash("Acceso denegado o token inv√°lido.", 'danger')
        cur.close()
        conn.close()
        return redirect(url_for('index'))

    # Comprobar si el token ha expirado
    if empresa_data['token_expiracion'] and datetime.now(empresa_data['token_expiracion'].tzinfo) > empresa_data['token_expiracion']:
        flash("El enlace de eliminaci√≥n ha caducado. Por favor, contacta con soporte si necesitas anular tu anuncio.", 'danger')
        cur.close()
        conn.close()
        return redirect(url_for('index'))

    try:
        # Eliminar imagen de GCS si existe
        if empresa_data['imagen_filename_gcs']:
            delete_from_gcs(empresa_data['imagen_filename_gcs'])
        
        # Eliminar la entrada de la base de datos
        cur.execute("DELETE FROM empresas WHERE id = %s AND token_edicion = %s", (empresa_id, token))
        conn.commit()
        flash('Tu anuncio ha sido eliminado con √©xito.', 'success')
    except psycopg2.Error as e:
        conn.rollback()
        print(f"Error de base de datos al eliminar empresa (anunciante): {e}")
        flash('Error al eliminar el anuncio. Por favor, int√©ntalo de nuevo.', 'danger')
    finally:
        cur.close()
        conn.close()

    return redirect(url_for('index')) # Redirige a la p√°gina principal

# Rutas para otras p√°ginas est√°ticas o informativas
@app.route('/valorar-empresa')
def valorar_empresa():
    return render_template('valorar_empresa.html')

@app.route('/estudio-ahorros')
def estudio_ahorros():
    return render_template('estudio_ahorros.html')

@app.route('/contacto')
def contacto():
    return render_template('contacto.html')

@app.route('/nota-legal')
def nota_legal():
    return render_template('nota_legal.html')

# Ruta de administraci√≥n (necesita un token para ser accesible)
@app.route('/admin')
def admin():
    token = request.args.get('admin_token')
    if token != ADMIN_TOKEN:
        return "Acceso denegado. Se requiere token de administrador.", 403

    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("SELECT * FROM empresas ORDER BY id DESC") # Ordena por ID para ver los m√°s recientes primero
    empresas = cur.fetchall()
    cur.close()
    conn.close()
    return render_template('admin.html', empresas=empresas, admin_token=token)


# Punto de entrada principal para ejecutar la aplicaci√≥n Flask
if __name__ == '__main__':
    # Obtiene el puerto del entorno o usa 5000 por defecto
    port = int(os.environ.get('PORT', 5000))
    # Ejecuta la aplicaci√≥n en modo debug si no est√° en producci√≥n
    app.run(host='0.0.0.0', port=port, debug=os.environ.get('FLASK_ENV') == 'development')
